# This Source Form is subject to the terms of the AQUA Software License,
# v. 1.0. Copyright (c) 2024 Aymeric Wibo

## The install map maps file names to where they should be installed.
## These destination paths are prefixed by the installation prefix, which can only be set by the user.
## On most common Linux distributions, this would be '/usr' by default.
## On FreeBSD, this is '/usr/local' by default.
##
## ```fl
## install = {
## 	"foo": "bin/foo",
## 	"bar": "bin/bar",
## }
## ```
install: map<str, str>

## Function to be called when the project is run.
## The arguments passed to Bob are passed as a vector of strings to the `args` parameter.
## The return value should be the exit code of the program (i.e. 0 on success and anything else on error).
##
## ```fl
## fn run(args) {
## 	return Sys.exec(cmd_path, args)
## }
## ```
##
## In the above example, it is assumed that `cmd_path` is the path to an executable generated by the build step.
fn run(args: vec<str>) -> int

## C compiler class.
extern class CC {
	## Add a flag to the C compiler.
	##
	## ```fl
	## cc.add_opt("-std=c99")
	## ```
	extern fn add_opt(self, option: str) -> void

	## Compile a C source file.
	## Returns the path to the object file.
	##
	## ```fl
	## object_file_path = cc.compile("main.c")
	## ```
	extern fn compile(self, src_path: str) -> str
}

## Linker class.
extern class Linker {
	## Create a static library ('.a') from a list of object files.
	## Returns the path to the static library.
	##
	## ```fl
	## lib_path = linker.static(["main.o", "foo.o", "bar.o"])
	## ```
	extern fn static(self, out_path: str) -> void

	## Create a dynamic library (aka a shared object, '.so') from a list of object files.
	## The second argument is a list of other libraries to link against.
	## For example, if your library necessarily depends on 'libm', you would pass '["m"]' as the second argument.
	## Returns the path to the dynamic library.
	##
	## ```fl
	## lib_path = linker.dynamic(["main.o", "foo.o", "bar.o"])
	## lib_path = linker.dynamic(["main.o", "foo.o", "bar.o"], ["m"])
	## ```
	extern fn dynamic(self, out_path: str, other_libs: vec<str> = []) -> void

	## Create an executable from a list of object files.
	## The second argument is a list of other libraries to link against.
	## For example, if your library necessarily depends on 'libm', you would pass '["m"]' as the second argument.
	## Returns the path to the executable.
	##
	## ```fl
	## exe_path = linker.link(["main.o", "foo.o", "bar.o"])
	## exe_path = linker.link(["main.o", "foo.o", "bar.o"], ["m"])
	## ```
	extern fn link(self, out_path: str, other_libs: vec<str> = []) -> void
}

## Resource class.
extern class Res {
	## Add a resource to the project.
	## This essentially copies your resource to the build directory untouched.
	## Returns the new path to the resource.
	##
	## ```
	## res_path = res.add("header.h")
	## ```
	extern pure fn add(path: str) -> str
}

## Dependency class.
extern class Dep {
	## Depend on another project.
	## For now, only projects containing a `build.fl` file at the root can be depended on.
	## The `url` argument is meant to be given as a URL to the project's directory.
	## Currently, only the `git://` and `file://` protocols are supported.
	##
	## ```fl
	## dep.add("git://github.com/username/project")
	## dep.add("file:///path/to/project")
	## ```
	extern fn add(url: str) -> void
}
